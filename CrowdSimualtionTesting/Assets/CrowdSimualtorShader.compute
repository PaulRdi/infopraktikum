// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel SetPositionsTex
#pragma kernel TestMove
#pragma kernel ResetTex
#pragma kernel Move

struct Agent {
	float3 position;
	float3 orientation;
	float4x4 modelMatrix;
	float speed;
	float angularVelocity;
	int id;
};



// Create a RenderTexture with enableRandomWrite flag and set it
RWTexture2D<float4> Result;
RWStructuredBuffer<Agent> Agents;
RWTexture2D<float4> WorldState;
float4x4 INVERSE_MATRIX_VP;
float4x4 MATRIX_VP;
float2 screenSize;

[numthreads(32, 18, 1)]
void ResetTex(uint3 id : SV_DispatchThreadID)
{
	WorldState[id.xy] = float4(0, 0, 0, 0);
}

[numthreads(32,18,1)]
//not getting this to work :(
void SetPositionsTex(uint3 id : SV_DispatchThreadID)
{
	float dist = 10000000;
	//screen coordinates from (0 -> 1) or (0 -> textureWidth)
	//https://answers.unity.com/questions/783770/screenspace-to-worldspace-in-computeshader.html
	float2 pixelPos = float2(((float)id.x), ((float)id.y));
	float2 clipPos = float2(
		2.0 * pixelPos.x * (1.0 / screenSize.x) - 1.0,
		1.0 - 2.0 * pixelPos.y * (1.0 / screenSize.y));

	float4 worldPos = mul(float4(clipPos, 1, 1), INVERSE_MATRIX_VP);
	float3 realWorldPos = worldPos.xyz * worldPos.w;
	//currently taking pixel distance from bottom left position of screen.
	for (uint i = 0; i < Agents.Length; ++i)
	{
		dist = min(dist, length(realWorldPos - Agents[i].position));
	}

	if (dist < 10)
		Result[id.xy] = float4(1, 0, 1, 0);
	else
		Result[id.xy] = float4(1, 1, 1, 0);
}

[numthreads(1024, 1, 1)]
void TestMove(uint3 id : SV_DispatchThreadID)
{
	Agents[id.x].angularVelocity = 3.0;

	float rotAmt = radians(3.0);
	float3 dir = Agents[id.x].orientation;
	Agents[id.x].orientation = float3(
		dir.x * cos(rotAmt) - dir.z * sin(rotAmt),
		0,
		dir.x * sin(rotAmt) + dir.z * cos(rotAmt));

	Agents[id.x].position.xyz += Agents[id.x].orientation;
}

[numthreads(1024, 1, 1)]
void Move(uint3 id : SV_DispatchThreadID)
{
	float4x4 mvp = mul(MATRIX_VP, Agents[id.x].modelMatrix);
	float4 f4pos = float4(Agents[id.x].position.x, Agents[id.x].position.y, Agents[id.x].position.z, 1.0);
	float4 screenPos = mul(mvp, f4pos);

	int lerpedX = round(lerp(0, (int)screenSize.x, screenPos.x));
	int lerpedY = round(lerp(0, (int)screenSize.y, screenPos.y));

	for (int y = lerpedY - 50; y < lerpedY + 50; y++)
	{
		for (int x = lerpedX - 50; x < lerpedX + 50; x++)
		{
			if (x == lerpedX && y == lerpedY)
				continue;
			WorldState[uint2(x, y)] = float4(1, 0, 1, 0);

			if (distance(WorldState[uint2(x, y)], float4(1, 1, 1, 1)) < 0.1)
			{
				Agents[x].speed = 0;
			}
		}
	}
	Agents[id.x].position += Agents[id.x].orientation * Agents[id.x].speed;

}